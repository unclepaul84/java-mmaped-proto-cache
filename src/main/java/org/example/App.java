/*
 * This source file was generated by the Gradle 'init' task
 */

package org.example;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.util.JsonFormat;
import com.google.protobuf.DynamicMessage;
import proto.*;
import com.google.protobuf.Descriptors;

import java.io.FileDescriptor;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

public class App {

        public static void main(String[] args)
                        throws Exception, com.google.protobuf.InvalidProtocolBufferException, IllegalArgumentException {

                var itemCount = Integer.parseInt(System.getenv().getOrDefault("ITEM_COUNT", "1000"));

                MMappedProtoHashMapCache<PriceScenariosOuterClass.PriceScenarios> priceScenariosMap = new MMappedProtoHashMapCache<>(
                                java.nio.file.Paths.get("price_scenarios"), bytes -> {
                                        try {
                                                return PriceScenariosOuterClass.PriceScenarios.parseFrom(bytes);
                                        } catch (InvalidProtocolBufferException e) {
                                                throw new RuntimeException("Failed to parse PriceScenarios", e);
                                        }
                                } );

              

                for (int i = 0; i < itemCount; i++) {
                        var pc = PriceScenariosOuterClass.PriceScenarios.newBuilder().setUnderlyer(("AAPL" + i))
                                        .setInstrumentSymbol(("AAPLDEC2023" + i));

                        for (int j = 0; j < 10000; j++) {

                                pc.addPrice(j * 0.1);
                        }
                        var sc = pc.build();

                        priceScenariosMap.put(sc.getInstrumentSymbol().getBytes(), sc);
                }

                long startTime = System.currentTimeMillis();
                int iterations = itemCount;
                int missingKeysCount = 0;

                for (int i = 0; i < iterations; i++) {
                        var key = ("AAPLDEC2023" + i);
                        var scenario = priceScenariosMap.get(key.getBytes());

                        if (scenario == null) {

                                missingKeysCount++;

                        } else {

                                if (!scenario.getInstrumentSymbol().equals(key))
                                        throw new IllegalArgumentException("Key mismatch: expected " + key
                                                        + ", but got " + scenario.getInstrumentSymbol());

                                
                        }

                }

                long endTime = System.currentTimeMillis();
                double finalAvgTime = (double) (endTime - startTime) / iterations;
                System.out.println("Average time for " + iterations + " iterations: " + finalAvgTime + " ms");
                System.out.println("Missing keys count: " + missingKeysCount);
        }
}
